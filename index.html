<!DOCTYPE html>
<html lang="en">
<head>
  <link rel="icon" type="image/png" href="logo.png">
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Reading Orwell in Moscow</title>
  <link href="https://fonts.googleapis.com/css2?family=Bebas+Neue&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="css/style.css" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@100..900&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css">

</head>
<body>
  <h1>Reading Orwell in Moscow</h1>
  <h2>Chronicle of Book Censorship in Contemporary Russia</h2>
  <div id="menu-buttons">
    <a href="index.html"><button class="active">timeline</button></a>
    <a href="statistics.html"><button>statistics</button></a>
    <a href="about.html"><button>about</button></a>
  </div>
  <div id="category-buttons" style="display:none;"></div>

  <div id="content">
  <div id="entries"></div>
  </div>

 <script>
let entries = [];
let currentCategory = 'full timeline';
let currentSubCategory = null;

// Load entries from JSON
fetch('entries.json')
  .then(response => response.json())
  .then(data => {
    entries = data.filter(entry => entry.public === 1);
    entries.sort((a, b) => new Date(b.date_parsed) - new Date(a.date_parsed));

    // Extract unique types from the data
    const types = Array.from(new Set(entries.map(e => e.type)));

    // Only show category buttons if on Full Timeline page
    const subContainer = document.getElementById('category-buttons');
    if (window.location.pathname.endsWith('index.html') || window.location.pathname === '/') {
      subContainer.style.display = 'flex';
      renderCategoryButtons(types); // render dynamically from JSON types
    }

    // Display all entries initially (full timeline)
    displayEntries('full timeline');
  })
  .catch(error => {
    document.getElementById('entries').textContent = 'Failed to load entries.';
    console.error(error);
  });


// Render secondary category buttons (sub-categories)
function renderCategoryButtons(subCategories) {
  const container = document.getElementById('category-buttons');
  container.innerHTML = '';
  container.style.display = 'flex'; // ensure visible

  subCategories.forEach(sub => {
    const btn = document.createElement('button');
    btn.textContent = sub;

    btn.onclick = () => {
      currentSubCategory = sub;
      displayEntries(currentCategory, currentSubCategory);

      // Highlight active sub-button
      document.querySelectorAll('#category-buttons button').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
    };

    container.appendChild(btn);
  });
}

// Display entries filtered by category and optionally sub-category
function displayEntries(category, subCategory = null) {
  const container = document.getElementById('entries');
  container.innerHTML = '';

  let filtered = category === 'full timeline'
    ? entries
    : entries.filter(entry => entry.type === category);

  if (subCategory) {
    filtered = filtered.filter(entry => entry.type.toLowerCase() === subCategory.toLowerCase());
  }

  // Group by year
  const byYear = {};
  filtered.forEach(entry => {
    const year = new Date(entry.date_parsed).getFullYear();
    if (!byYear[year]) byYear[year] = [];
    byYear[year].push(entry);
  });

  const sortedYears = Object.keys(byYear).sort((a, b) => b - a);

  sortedYears.forEach(year => {
    const yearEntries = byYear[year];

    // YEAR HEADER
    const yearHeader = document.createElement('div');
    yearHeader.className = 'year-header';
    yearHeader.textContent = year;
    container.appendChild(yearHeader);

    // If ≥20 entries → group by month
    const shouldGroupByMonth = yearEntries.length >= 20;
    if (shouldGroupByMonth) {
      const byMonth = {};
      yearEntries.forEach(entry => {
        const month = new Date(entry.date_parsed).getMonth();
        if (!byMonth[month]) byMonth[month] = [];
        byMonth[month].push(entry);
      });

      const sortedMonths = Object.keys(byMonth)
        .map(m => parseInt(m))
        .sort((a, b) => b - a);

      sortedMonths.forEach(month => {
        const monthHeader = document.createElement('div');
        monthHeader.className = 'month-header';
        monthHeader.textContent = monthName(new Date(year, month, 1));
        container.appendChild(monthHeader);

        byMonth[month].forEach(entry => {
          container.appendChild(buildEntry(entry, category === 'full timeline'));
        });
      });

    } else {
      yearEntries.forEach(entry => {
        container.appendChild(buildEntry(entry, category === 'full timeline'));
      });
    }
  });
}

// Helper: month name
function monthName(dateObj) {
  return dateObj.toLocaleString('en-US', { month: 'long' });
}

// Build entry DOM
function buildEntry(entry, showType = false) {
  const entryDiv = document.createElement('div');
  entryDiv.className = 'entry';
  entryDiv.id = entry.id;

  if (showType) {
    const typeElem = document.createElement('div');
    typeElem.classList.add('entry-type');
    typeElem.textContent = entry.type;
    entryDiv.appendChild(typeElem);
  }

  const dateElem = document.createElement('div');
  dateElem.className = 'entry-date';
  dateElem.textContent = entry.date;

  const descElem = document.createElement('p');
  descElem.innerHTML = entry.description;

  entryDiv.appendChild(dateElem);
  entryDiv.appendChild(descElem);

  // SOURCE
  if (entry.source && entry.source !== '') {
    const sourceContainer = document.createElement('div');
    sourceContainer.classList.add('entry-source');

    if (entry.source === 'url') {
      ['url1', 'url2', 'url3'].forEach((key, i) => {
        if (entry[key] && entry[key].trim() !== '') {
          const link = document.createElement('a');
          link.href = entry[key];
          link.target = '_blank';
          link.rel = 'noopener noreferrer';
          link.textContent = '[source]';
          link.classList.add('source-link');
          sourceContainer.appendChild(link);

          if (i < 2 && entry[key + 1] && entry[key + 1].trim() !== '') {
            sourceContainer.appendChild(document.createTextNode(' '));
          }
        }
      });
    } else {
      sourceContainer.textContent = entry.source;
    }

    entryDiv.appendChild(sourceContainer);
  }

  // LOCATION
  if (entry.location && entry.location.trim() !== '') {
    const locationElem = document.createElement('div');
    locationElem.classList.add('entry-location');

    const icon = document.createElement('i');
    icon.className = 'fa fa-location-arrow';
    icon.setAttribute('aria-hidden', 'true');

    locationElem.appendChild(icon);
    locationElem.appendChild(document.createTextNode(' ' + entry.location));
    entryDiv.appendChild(locationElem);
  }

  return entryDiv;
}
</script>


<footer class="page-footer">© 2025</footer>
</body>
</html>

